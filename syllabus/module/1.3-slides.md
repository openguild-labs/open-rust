---
title: Module 1.3 - Ownership & Borrow Checker
description: "Ownership & Borrow Checker"
duration: 30 minutes
---

# Ownership

---

## Managing memory

- Programs must track memory
  - If they fail to do so, a “leak” occurs
- Rust utilizes an “ownership” model to manage memory
  - The “owner” of memory is responsible for cleaning up the memory
- Memory can either be “moved” or “borrowed”

---

## Example - Move

```rust
enum Light {
    Bright,
    Dull,
}

fn display_light(light: Light) {
    match light {
        Light::Bright => println!("bright"),
        Light::Dull => println!("dull"),
    }
}

fn main() {
    let dull = Light::Dull;
    display_light(dull);
    display_light(dull);
}

```

---

## Example - Borrow

```rust
enum Light {
    Bright,
    Dull,
}

fn display_light(light: &Light) {
    match light {
        Light::Bright => println!("bright"),
        Light::Dull => println!("dull"),
    }
}

fn main() {
    let dull = Light::Dull;
    display_light(&dull);
    display_light(&dull);
}

```

---

## Vector

- Multiple pieces of data
  - Must be the same type
- Used for lists of information
- Can add, remove, and traverse the entries

---

## Example

```rust
let my_numbers = vec![1, 2, 3];

let mut my_numbers = Vec::new();
my_numbers.push(1);
my_numbers.push(2);
my_numbers.push(3);
my_numbers.pop();
let length = my_numbers.len(); // this is 2

let two = my_numbers[1];
```

---

## Example

```rust
let my_numbers = vec![1, 2, 3];

for num in my_numbers {
    println!("{:?}", num);
}
```

---

## String and &str

- Two commonly used types of strings
  - String - owned
  - &str – borrowed String slice
- Must use an owned String to store in a struct
- Use &str when passing to a function

---

## Example – Pass to function

```rust
fn print_it(data: &str) {
    println!("{:?}", data);
}

fn main() {
    print_it("a string slice");
    let owned_string = "owned string".to_owned();
    let another_owned = String::from("another");
    print_it(&owned_string);
    print_it(&another_owned);
}
```

---

## Example – Will not work

```rust
struct Employee {
    name: &'static str,
}

fn main() {
    let emp_name = "Jayson";
    let emp = Employee {
        name: emp_name,
    };
}
```

---

## Example – Works!

```rust
struct Employee {
    name: String,
}

fn main() {
    let emp_name = "Jayson".to_owned();
    let emp = Employee {
        name: emp_name
    };
}

```

---

## Type Annotations

- Required for function signatures
- Types are usually inferred
- Can also be specified in code
  - Explicit type annotations

---

## Example - Basic

```rust
fn print_many(msg: &str, count: i32) {
    // Presumably the body of the function would print the message many times
    // but since it's not shown in the image, it's left empty here.
}

enum Mouse {
    LeftClick,
    RightClick,
    MiddleClick,
}

fn main() {
    let num: i32 = 15;
    let a: char = 'a';
    let left_click: Mouse = Mouse::LeftClick;
}
```

---

## Example - Generics

```rust
enum Mouse {
    LeftClick,
    RightClick,
    MiddleClick,
}

let numbers: Vec<i32> = vec![1, 2, 3];
let letters: Vec<char> = vec!['a', 'b'];
let clicks: Vec<Mouse> = vec![
    Mouse::LeftClick,
    Mouse::LeftClick,
    Mouse::RightClick,
];
```

---

## Enums

- enum is a type that can represent one item at a time
  - Each item is called a variant
- enum is not limited to just plain variants
  - Each variant can optionally contain additional data

---

## Example

```rust
enum Mouse {
    LeftClick,
    RightClick,
    MiddleClick,
    Scroll(i32),
    Move(i32, i32),
}
```

---

## Example

```rust
enum PromoDiscount {
    NewUser,
    Holiday(String),
}

enum Discount {
    Percent(f64),
    Flat(i32),
    Promo(PromoDiscount),
    Custom(String),
}
```

---

## Option

- A type that may be one of two things
  - Some data of a specified type
  - Nothing
- Used in scenarios where data may not be required or is unavailable
  - Unable to find something
  - Ran out of items in a list
  - Form field not filled out

---

## Definition

```rust
enum Option<T> {
    Some(T),
    None,
}

```

## Example

```rust
struct Customer {
    age: Option<i32>,
    email: String,
}

let mark = Customer {
    age: Some(22),
    email: "mark@example.com".to_owned(),
};

let becky = Customer {
    age: None,
    email: "becky@example.com".to_owned(),
};

match becky.age {
    Some(age) => println!("customer is {} years old", age),
    None => println!("customer age not provided"),
}
```

---

## Example

```rust
struct GroceryItem {
    name: String,
    qty: i32,
}

fn find_quantity(name: &str) -> Option<i32> {
    let groceries = vec![
        GroceryItem { name: "bananas".to_owned(), qty: 4 },
        GroceryItem { name: "eggs".to_owned(), qty: 12 },
        GroceryItem { name: "bread".to_owned(), qty: 1 },
    ];

    for item in groceries {
        if item.name == name {
            return Some(item.qty);
        }
    }

    None
}
```

---

## Result

- A data type that contains one of two types of data:
  - “Successful” data
  - “Error” data
- Used in scenarios where an action needs to be taken, but has the possibility of failure
  - Copying a file
  - Connecting to a website

---

## Definition

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

---

## Example

```rust
struct SoundData {
    // assuming SoundData has a field called `name`
    name: String,
}

impl SoundData {
    fn new(name: &str) -> SoundData {
        SoundData {
            name: name.to_owned(),
        }
    }
}

fn get_sound(name: &str) -> Result<SoundData, String> {
    if name == "alert" {
        Ok(SoundData::new("alert"))
    } else {
        Err("unable to find sound data".to_owned())
    }
}

fn main() {
    let sound = get_sound("alert");
    match sound {
        Ok(_) => println!("sound data located"),
        Err(e) => println!("error: {}", e),
    }
}
```

---

## Hashmap

- Collection that stores data as key-value pairs
  - Data is located using the “key”
  - The data is the “value”
- Similar to definitions in a dictionary
- Very fast to retrieve data using the key

---

## Example: find data

```rust
use std::collections::HashMap;

fn main() {
    let mut people = HashMap::new();
    people.insert("Susan", 21);
    people.insert("Ed", 13);
    people.insert("Will", 14);
    people.insert("Cathy", 22);
    people.remove("Susan");

    match people.get("Ed") {
        Some(age) => println!("age = {:?}", age),
        None => println!("not found"),
    }
}

```

---

## Example: iterate

```rust
for (person, age) in people.iter() {
    println!("person = {:?}, age = {:?}", person, age);
}

for person in people.keys() {
    println!("person = {:?}", person);
}

for age in people.values() {
    println!("age = {:?}", age);
}

```

## Basic memory refresh

- Memory is stored using binary
  - Bits: 0 or 1
- Computer optimized for bytes
  - 1 byte == 8 contiguous bits
- Fully contiguous

---

## Addresses

- All data in memory has an “address”
  - Used to locate data
  - Always the same – only data changes
- Usually don’t utilize addresses directly
  - Variables handle most of the work

---

## Offsets

- Items can be located at an address using an “offset”
- Offsets begin at 0
- Represent the number of bytes away from the original address
  - Normally deal with indexes instead
