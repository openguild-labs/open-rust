<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>Module 1.2 - Program Life Cycle</title>
  <link rel="icon" href="./../../assets/favicon.svg" />
  <link rel="shortcut icon" href="./../../assets/favicon.png" />
  <link rel="stylesheet" href="./../../dist/reset.css" />
  <link rel="stylesheet" href="./../../dist/reveal.css" />
  <link rel="stylesheet" href="./../.././assets/styles/PBA-theme.css" id="theme" />
  <link rel="stylesheet" href="./../../css/highlight/shades-of-purple.css" />

  <link rel="stylesheet" href="./../.././assets/styles/custom-classes.css" />

</head>

<body class="site">
  <header class="site-header">
    <!-- This logo is a link only on the watching server, not the production build -->
    <a href="">
      <img style="height: 2.5vw;" class="watermark-logo" src="./../../assets/img/0-Shared/logo/openguild-logo.png"
        alt="PBA Logo">
    </a>
  </header>
  <main class="reveal">
    <article class="slides">
      <section  data-markdown><script type="text/template">

# Fundamentals
</script></section><section  data-markdown><script type="text/template">
## Execution Flow

- Code executed line-by-line
- Actions are performed & control flow may change
  - Specific conditions can change control flow
    - “if”
    - “else”
    - “else if”

<aside class="notes"><p>Mã được thực thi theo từng dòng:</p>
<p>Trong hầu hết các ngôn ngữ lập trình, mã được thực thi theo trình tự từng dòng một. Trình tự này xác định thứ tự các lệnh được thực hiện.
Các hành động được thực hiện và luồng điều khiển có thể thay đổi:</p>
<p>Khi mã được thực thi, các hành động hoặc lệnh được thực hiện và luồng điều khiển của chương trình có thể thay đổi dựa trên các điều kiện nhất định.
Các điều kiện cụ thể có thể thay đổi luồng điều khiển:</p>
<p>Các cấu trúc điều khiển như if, else, và else if cho phép thay đổi luồng thực thi dựa trên các điều kiện cụ thể:
if: Sử dụng để kiểm tra một điều kiện. Nếu điều kiện đúng, khối mã bên trong sẽ được thực hiện.
else: Sử dụng kết hợp với if để chỉ định khối mã sẽ được thực hiện nếu điều kiện if là sai.
else if: Sử dụng để kiểm tra một điều kiện khác nếu điều kiện if ban đầu là sai. Điều này cho phép kiểm tra nhiều điều kiện khác nhau và thực thi khối mã tương ứng.
Các cấu trúc điều khiển này rất quan trọng để lập trình viên có thể điều chỉnh luồng thực thi của chương trình dựa trên các điều kiện cụ thể, giúp chương trình trở nên linh hoạt và đáp ứng được các tình huống khác nhau.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Example – if..else

```rust
let a = 99;
if a > 99 {
    println!("Big number");
} else {
    println!("Small number");
}
```
</script></section><section  data-markdown><script type="text/template">
## Example – Nested if..else

```rust
let a = 99;
if a > 99 {
    if a > 200 {
        println!("Huge number");
    } else {
        println!("Big number");
    }
} else {
    println!("Small number");
}
```

<aside class="notes"><p>cấu trúc điều khiển lồng nhau (nested if..else) trong lập trình</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Example – if..else if..else

```rust
let a = 99;
if a > 200 {
    println!("Huge number");
} else if a > 99 {
    println!("Big number");
} else {
    println!("Small number");
}

// This will not work
if a > 99 {
    println!("Big number");
} else if a > 200 {
    println!("Huge number");
} else {
    println!("Small number");
}
```

<aside class="notes"><p>Vì điều kiện a &gt; 99 được kiểm tra trước và nó đã đúng với giá trị 99, chương trình sẽ luôn in ra &quot;Big number&quot; và bỏ qua các điều kiện sau đó. Điều này không đúng với logic mong muốn khi kiểm tra các giá trị lớn hơn 200 trước.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Repetition

- Called “looping” or “iteration”
- Multiple types of loops
  - “loop” - infinite loop
  - “while” – conditional loop

<aside class="notes"><p>Gọi là &quot;looping&quot; hoặc &quot;iteration&quot;:</p>
<p>Lặp lại trong lập trình thường được gọi là &quot;looping&quot; hoặc &quot;iteration&quot;. Đây là quá trình thực hiện một đoạn mã nhiều lần.
Nhiều loại vòng lặp khác nhau:</p>
<p>Có nhiều loại vòng lặp khác nhau trong lập trình, mỗi loại có cách thức hoạt động và mục đích sử dụng riêng. Hai loại vòng lặp phổ biến được liệt kê trong hình là:
loop - vòng lặp vô hạn (infinite loop):
Vòng lặp loop sẽ chạy mã bên trong nó vô hạn lần cho đến khi có lệnh dừng (như break) được gọi. Điều này có nghĩa là nếu không có lệnh dừng, vòng lặp sẽ tiếp tục chạy mãi mãi.
while - vòng lặp điều kiện (conditional loop):
Vòng lặp while sẽ tiếp tục chạy mã bên trong nó miễn là điều kiện kiểm tra là đúng. Khi điều kiện trở nên sai, vòng lặp sẽ dừng lại. Điều này cho phép thực hiện mã lặp đi lặp lại dựa trên một điều kiện cụ thể.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Loop

```rust
let mut a = 0;
loop {
    if a == 5 {
        break;
    }
    println!("{:?}", a);
    a = a + 1;
}

```
</script></section><section  data-markdown><script type="text/template">
## While loop

```rust
let mut a = 0;
while a != 5 {
    println!("{:?}", a);
    a = a + 1;
}
```
</script></section><section  data-markdown><script type="text/template">
## Match

- Add logic to program
- Similar to if..else
- Exhaustive
  - All options must be accounted for

<aside class="notes"><p>Thêm logic vào chương trình:</p>
<p>Cấu trúc match được sử dụng để thêm logic vào chương trình bằng cách so sánh giá trị của một biến với các mẫu (patterns) khác nhau và thực hiện các hành động tương ứng.
Tương tự như if..else:</p>
<p>Cấu trúc match có chức năng tương tự như if..else, nhưng thường dễ đọc và gọn gàng hơn khi cần kiểm tra nhiều điều kiện khác nhau.
Toàn diện (Exhaustive):</p>
<p>Cấu trúc match yêu cầu phải kiểm tra tất cả các khả năng có thể xảy ra của biến, đảm bảo rằng không có trường hợp nào bị bỏ sót. Nếu không, trình biên dịch sẽ báo lỗi.
Tất cả các tùy chọn phải được tính đến (All options must be accounted for): Mọi giá trị khả thi của biến phải được xử lý, điều này giúp đảm bảo rằng chương trình không bỏ sót bất kỳ trường hợp nào và tăng cường tính an toàn của mã nguồn.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Example with boolean

```rust
fn main() {
    let some_bool = true;
    match some_bool {
        true => println!("it's true"),
        false => println!("it's false"),
    }
}

```
</script></section><section  data-markdown><script type="text/template">
## Example with int

```rust
fn main() {
    let some_int = 3;
    match some_int {
        1 => println!("it's 1"),
        2 => println!("it's 2"),
        3 => println!("it's 3"),
        _ => println!("it's something else"),
    }
}

```
</script></section><section  data-markdown><script type="text/template">
## match vs else..if

- match will be checked by the compiler
  - If a new possibility is added, you will be notified when this occurs
- else..if is not checked by the compiler
  - If a new possibility is added, your code may contain a bug

<aside class="notes"><p>So sánh match và else..if
match sẽ được kiểm tra bởi trình biên dịch:</p>
<p>Trình biên dịch Rust sẽ kiểm tra cấu trúc match để đảm bảo rằng tất cả các trường hợp có thể xảy ra đều được xử lý.
Nếu một khả năng mới được thêm vào, bạn sẽ được thông báo khi điều này xảy ra:
Nếu có một giá trị mới hoặc trường hợp mới được thêm vào, trình biên dịch sẽ báo lỗi nếu bạn không xử lý trường hợp đó trong cấu trúc match. Điều này giúp tránh lỗi và đảm bảo rằng tất cả các trường hợp đều được xử lý đúng cách.
else..if không được kiểm tra bởi trình biên dịch:</p>
<p>Cấu trúc else..if không được trình biên dịch Rust kiểm tra toàn diện như match.
Nếu một khả năng mới được thêm vào, mã của bạn có thể chứa lỗi:
Nếu có một giá trị mới hoặc trường hợp mới được thêm vào, bạn sẽ không được trình biên dịch cảnh báo nếu bạn quên xử lý trường hợp đó. Điều này có thể dẫn đến lỗi trong chương trình.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Iterator

- Iteration is provided by the Iterator trait
  - Only one function to be implemented
  - Provides for..in syntax
  - Access to all iterator adapters
    - map, take, filter, etc
- Can be implemented for any structure

<aside class="notes"><p>Quá trình lặp được cung cấp bởi đặc tính Iterator:</p>
<p>Trong Rust, quá trình lặp lại trên các phần tử của một cấu trúc dữ liệu được cung cấp bởi đặc tính (trait) Iterator.
Chỉ cần triển khai một hàm:</p>
<p>Để tạo một iterator tùy chỉnh, bạn chỉ cần triển khai một hàm duy nhất, đó là hàm next. Hàm này trả về phần tử kế tiếp trong chuỗi hoặc None khi không còn phần tử nào.
Cung cấp cú pháp for..in:</p>
<p>Khi một cấu trúc dữ liệu triển khai đặc tính Iterator, bạn có thể sử dụng cú pháp for..in để lặp qua các phần tử của nó một cách dễ dàng.
Truy cập tất cả các bộ chuyển đổi iterator:</p>
<p>Khi một iterator đã được tạo, bạn có thể truy cập và sử dụng tất cả các bộ chuyển đổi iterator (iterator adapters) như map, take, filter, v.v. Các bộ chuyển đổi này giúp thao tác và biến đổi các phần tử của iterator.
Có thể được triển khai cho bất kỳ cấu trúc nào:</p>
<p>Đặc tính Iterator có thể được triển khai cho bất kỳ cấu trúc dữ liệu nào, cho phép bạn tạo ra các iterator tùy chỉnh cho các kiểu dữ liệu cụ thể của bạn.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Iterator Trait

```rust
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}
```

<aside class="notes"><p>Định nghĩa trait Iterator
trait Iterator:</p>
<p>Đây là định nghĩa của một trait tên là Iterator. Trong Rust, trait là một tập hợp các phương thức mà một kiểu dữ liệu có thể triển khai.
type Item:</p>
<p>Đây là một kiểu liên kết (associated type). Item đại diện cho kiểu dữ liệu của các phần tử mà iterator sẽ trả về. Khi triển khai trait Iterator cho một kiểu dữ liệu cụ thể, bạn cần chỉ định kiểu dữ liệu cho Item.
fn next(&amp;mut self) -&gt; OptionSelf::Item:</p>
<p>Đây là phương thức bắt buộc cần phải triển khai khi một kiểu dữ liệu triển khai trait Iterator.
Phương thức next nhận một tham chiếu thay đổi đến chính nó (&amp;mut self) và trả về Option<a href="Self::Item">Self::Item</a>.
Option<a href="Self::Item">Self::Item</a> có thể là Some(Item) nếu iterator có phần tử kế tiếp hoặc None nếu iterator đã hoàn thành việc lặp.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Example - Iterator

```rust
struct Odd {
    number: isize,
    max: isize,
}

impl Iterator for Odd {
    type Item = isize;

    fn next(&mut self) -> Option<Self::Item> {
        self.number += 2;
        if self.number <= self.max {
            Some(self.number)
        } else {
            None
        }
    }
}
```

<aside class="notes"><p>struct Odd:
Đây là định nghĩa của một cấu trúc (struct) tên là Odd. Cấu trúc này chứa hai trường:
number: một số nguyên kiểu isize.
max: một số nguyên kiểu isize.</p>
<p>Ví dụ này minh họa cách triển khai trait Iterator cho một cấu trúc tùy chỉnh trong Rust. Cụ thể, chúng ta triển khai Iterator cho cấu trúc Odd để lặp qua các số lẻ. Dưới đây là giải thích chi tiết về từng phần của đoạn mã:</p>
<p>Định nghĩa cấu trúc Odd
rust
Copy code
struct Odd {
    number: isize,
    max: isize,
}
struct Odd:
Đây là định nghĩa của một cấu trúc (struct) tên là Odd. Cấu trúc này chứa hai trường:
number: một số nguyên kiểu isize.
max: một số nguyên kiểu isize.
Triển khai trait Iterator cho Odd
rust
Copy code
impl Iterator for Odd {
    type Item = isize;</p>
<pre><code>fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    self.number += 2;
    if self.number &lt;= self.max {
        Some(self.number)
    } else {
        None
    }
}
</code></pre>
<p>}
impl Iterator for Odd:</p>
<p>Đây là phần triển khai trait Iterator cho cấu trúc Odd.
type Item = isize:</p>
<p>Xác định kiểu dữ liệu cho các phần tử mà iterator sẽ trả về. Trong trường hợp này, Item là isize, nghĩa là iterator sẽ trả về các số nguyên kiểu isize.
fn next(&amp;mut self) -&gt; OptionSelf::Item:</p>
<p>Đây là phương thức next được triển khai từ trait Iterator.
self.number += 2;:
Tăng giá trị của self.number thêm 2 để di chuyển đến số lẻ tiếp theo.
if self.number &lt;= self.max {:
Kiểm tra xem giá trị của self.number có nhỏ hơn hoặc bằng self.max không.
Some(self.number): Nếu điều kiện đúng, trả về Some(self.number), đại diện cho số lẻ tiếp theo.
None: Nếu điều kiện sai, trả về None, đại diện cho việc iterator đã hoàn thành.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Example - Iterator

```rust
impl Odd {
    fn new(max: isize) -> Self {
        Self { number: -1, max }
    }
}

fn main() {
    let mut odds = Odd::new(7);
    println!("{:?}", odds.next()); // Some(1)
    println!("{:?}", odds.next()); // Some(3)
    println!("{:?}", odds.next()); // Some(5)
    println!("{:?}", odds.next()); // Some(7)
    println!("{:?}", odds.next()); // None
}
```

<aside class="notes"><p>impl Odd:</p>
<p>Đây là phần triển khai các phương thức cho cấu trúc Odd.
fn new(max: isize) -&gt; Self:</p>
<p>Đây là phương thức khởi tạo (constructor) cho cấu trúc Odd.
Self { number: -1, max }:
Phương thức này tạo ra một đối tượng Odd mới với giá trị ban đầu của number là -1 và giá trị max được truyền vào.
fn main():</p>
<p>Đây là hàm chính của chương trình, nơi chương trình bắt đầu thực thi.
let mut odds = Odd::new(7);:</p>
<p>Tạo một đối tượng Odd mới với giá trị tối đa là 7 bằng cách gọi phương thức khởi tạo new.
println!(&quot;{:?}&quot;, odds.next()); // Some(1):</p>
<p>Gọi phương thức next trên đối tượng odds và in ra kết quả.
Kết quả sẽ là Some(1) vì giá trị ban đầu của number là -1, và sau khi gọi next, giá trị được tăng thêm 2 và trở thành 1.
Các lệnh println! tiếp theo:</p>
<p>Tiếp tục gọi next và in ra kết quả. Mỗi lần gọi next, giá trị của number được tăng thêm 2 cho đến khi vượt quá giá trị max là 7. Sau đó, next sẽ trả về None.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Example – for..in

```rust
let mut odds = Odd::new(7);
for o in odds {
    println!("odd: {}", o);
}

// odd: 1
// odd: 3
// odd: 5
// odd: 7

```

<aside class="notes"><p>Sử dụng cú pháp for..in
Khởi tạo một đối tượng Odd mới:</p>
<p>rust
Copy code
let mut odds = Odd::new(7);
Tạo một đối tượng Odd mới với giá trị tối đa là 7 bằng cách gọi phương thức khởi tạo new.
Sử dụng cú pháp for..in để lặp qua các phần tử:</p>
<p>rust
Copy code
for o in odds {
    println!(&quot;odd: {}&quot;, o);
}
Cú pháp for..in được sử dụng để lặp qua tất cả các phần tử mà iterator odds cung cấp.
Mỗi phần tử o sẽ được in ra bằng lệnh println!.
Kết quả mong đợi
Khi đoạn mã này được thực thi, kết quả sẽ là:</p>
<p>plaintext
Copy code
odd: 1
odd: 3
odd: 5
odd: 7</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Example – Adapters

```rust
let mut evens = Odd::new(8);
for e in evens.map(|odd| odd + 1) {
    println!("even: {}", e);
}

// even: 2
// even: 4
// even: 6
// even: 8
```

<aside class="notes"><p>Sử dụng map để chuyển đổi các phần tử của iterator
rust
Copy code
let mut evens = Odd::new(8);
for e in evens.map(|odd| odd + 1) {
    println!(&quot;even: {}&quot;, e);
}
Khởi tạo một đối tượng Odd mới:</p>
<p>rust
Copy code
let mut evens = Odd::new(8);
Tạo một đối tượng Odd mới với giá trị tối đa là 8 bằng cách gọi phương thức khởi tạo new.
Sử dụng map để chuyển đổi các phần tử:</p>
<p>rust
Copy code
for e in evens.map(|odd| odd + 1) {
    println!(&quot;even: {}&quot;, e);
}
Sử dụng bộ chuyển đổi map để chuyển đổi mỗi phần tử của iterator evens. Hàm map nhận vào một hàm closure (|odd| odd + 1), áp dụng hàm này cho mỗi phần tử của iterator evens và trả về một iterator mới với các giá trị đã được chuyển đổi.
Cú pháp for e in evens.map(...) được sử dụng để lặp qua các phần tử của iterator đã được chuyển đổi và in ra các số chẵn tương ứng.
Kết quả mong đợi
Khi đoạn mã này được thực thi, kết quả sẽ là:</p>
<p>plaintext
Copy code
even: 2
even: 4
even: 6
even: 8</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Iterator Trait

- By default requires mutable access to structure
  - Inconvenient
  - Not always possible
  - Mutation not always needed
- Solution:
  - Implement IntoIterator trait & call .iter() on inner collection
    - Vector, HashMap

<aside class="notes"><p>Đặc tính Iterator
Mặc định yêu cầu truy cập thay đổi vào cấu trúc dữ liệu:</p>
<p>Bất tiện (Inconvenient):
Điều này có thể gây bất tiện trong một số trường hợp khi bạn không muốn thay đổi dữ liệu mà chỉ muốn lặp qua nó.
Không phải lúc nào cũng có thể (Not always possible):
Trong một số tình huống, bạn không thể hoặc không muốn thay đổi dữ liệu, chẳng hạn như khi dữ liệu được chia sẻ giữa nhiều luồng.
Không phải lúc nào cũng cần thay đổi (Mutation not always needed):
Trong nhiều trường hợp, bạn chỉ cần đọc dữ liệu mà không cần thay đổi nó.
Giải pháp:</p>
<p>Triển khai đặc tính IntoIterator và gọi .iter() trên bộ sưu tập bên trong:
Để giải quyết vấn đề này, bạn có thể triển khai đặc tính IntoIterator cho cấu trúc dữ liệu của mình và sử dụng phương thức .iter() để lặp qua các phần tử mà không cần thay đổi chúng.
Ví dụ với Vector và HashMap:
Vector và HashMap là hai ví dụ về các bộ sưu tập có thể triển khai đặc tính IntoIterator và sử dụng .iter() để lặp qua các phần tử một cách an toàn và hiệu quả mà không cần thay đổi dữ liệu.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## IntoIterator Trait

- Yields an Iterator (yield items/values)
  - Implementation details determine how items are accessed
  - Borrow, mutable, move

<aside class="notes"><p>Đặc tính IntoIterator
Trả về một Iterator (yield items/values):</p>
<p>Đặc tính IntoIterator cho phép một cấu trúc dữ liệu có thể chuyển đổi thành một iterator. Điều này có nghĩa là bạn có thể lấy các phần tử từ cấu trúc dữ liệu đó một cách tuần tự.
Chi tiết triển khai xác định cách truy cập các phần tử:</p>
<p>Cách triển khai đặc tính IntoIterator xác định cách các phần tử được truy cập trong iterator.
Borrow, mutable, move:
Borrow: Cho phép mượn (borrow) các phần tử mà không thay đổi chúng.
Mutable: Cho phép thay đổi (mutate) các phần tử khi chúng được lặp qua.
Move: Di chuyển (move) các phần tử ra khỏi cấu trúc dữ liệu, nghĩa là sau khi iterator kết thúc, các phần tử không còn trong cấu trúc dữ liệu ban đầu nữa.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## IntoIterator Trait

```rust
trait IntoIterator {
    type Item;
    type IntoIter: Iterator<Item = Self::Item>;

    fn into_iter(self) -> Self::IntoIter;
}
```

<aside class="notes"><p>trait IntoIterator:</p>
<p>Đây là định nghĩa của một trait tên là IntoIterator. Trait này cho phép một kiểu dữ liệu có thể được chuyển đổi thành một iterator.
type Item:</p>
<p>Đây là một kiểu liên kết (associated type). Item đại diện cho kiểu dữ liệu của các phần tử mà iterator sẽ trả về.
type IntoIter: Iterator&lt;Item = Self::Item&gt;:</p>
<p>IntoIter là một kiểu liên kết khác, đại diện cho kiểu của iterator mà trait IntoIterator sẽ trả về.
Iterator&lt;Item = Self::Item&gt; chỉ ra rằng kiểu này phải triển khai trait Iterator và trả về các phần tử có kiểu Item.
fn into_iter(self) -&gt; Self::IntoIter:</p>
<p>Phương thức into_iter chuyển đổi self (một đối tượng của kiểu triển khai trait IntoIterator) thành một iterator.
Phương thức này trả về Self::IntoIter, nghĩa là nó trả về một iterator có kiểu được xác định bởi kiểu IntoIter.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Move

```rust
struct Friends {
    names: Vec<String>,
}

impl IntoIterator for Friends {
    type Item = String;
    type IntoIter = std::vec::IntoIter<Self::Item>;

    fn into_iter(self) -> Self::IntoIter {
        self.names.into_iter()
    }
}
```

<aside class="notes"><p>Ví dụ này minh họa cách triển khai trait IntoIterator cho một cấu trúc dữ liệu tùy chỉnh trong Rust, cụ thể là Friends. Đây là cách triển khai IntoIterator cho phép di chuyển (move) các phần tử ra khỏi cấu trúc dữ liệu. Dưới đây là giải thích chi tiết về từng phần của đoạn mã:</p>
<p>Định nghĩa và triển khai cấu trúc Friends
rust
Copy code
struct Friends {
    names: Vec<String>,
}
struct Friends:
Đây là định nghĩa của một cấu trúc (struct) tên là Friends. Cấu trúc này chứa một trường:
names: một vector chứa các chuỗi ký tự (Vec<String>).
Triển khai trait IntoIterator cho Friends
rust
Copy code
impl IntoIterator for Friends {
    type Item = String;
    type IntoIter = std::vec::IntoIter<a href="Self::Item">Self::Item</a>;</p>
<pre><code>fn into_iter(self) -&gt; Self::IntoIter {
    self.names.into_iter()
}
</code></pre>
<p>}
impl IntoIterator for Friends:</p>
<p>Đây là phần triển khai trait IntoIterator cho cấu trúc Friends.
type Item = String:</p>
<p>Xác định kiểu dữ liệu cho các phần tử mà iterator sẽ trả về. Trong trường hợp này, Item là String, nghĩa là iterator sẽ trả về các chuỗi ký tự.
type IntoIter = std::vec::IntoIterSelf::Item:</p>
<p>IntoIter là kiểu của iterator mà trait IntoIterator sẽ trả về. Trong trường hợp này, IntoIter là std::vec::IntoIter<a href="Self::Item">Self::Item</a>, một iterator cho vector các chuỗi ký tự.
fn into_iter(self) -&gt; Self::IntoIter:</p>
<p>Phương thức into_iter chuyển đổi self (một đối tượng của kiểu Friends) thành một iterator.
self.names.into_iter():
Phương thức này gọi into_iter trên trường names của đối tượng Friends, di chuyển các phần tử ra khỏi vector và trả về một iterator cho vector đó.
Kết luận
Trong ví dụ này, chúng ta đã triển khai trait IntoIterator cho cấu trúc Friends để cho phép di chuyển các phần tử ra khỏi cấu trúc dữ liệu khi iterator được tạo. Điều này cho phép chúng ta lặp qua các phần tử của Friends mà không cần giữ lại dữ liệu ban đầu, giúp giải phóng bộ nhớ và tối ưu hóa hiệu suất. Việc triển khai IntoIterator như vậy mang lại sự linh hoạt và mạnh mẽ trong việc xử lý dữ liệu trong Rust.</p>
</aside></script></section><section  data-markdown><script type="text/template">
```rust
struct Friends {
    names: Vec<String>,
}

impl IntoIterator for Friends {
    type Item = String;
    type IntoIter = std::vec::IntoIter<Self::Item>;

    fn into_iter(self) -> Self::IntoIter {
        self.names.into_iter()
    }
}

for f in friends {
    println!("{:?}", f);
}
```

<aside class="notes"><p>Ví dụ này minh họa cách triển khai trait IntoIterator cho cấu trúc Friends và sử dụng nó để lặp qua các phần tử của cấu trúc này. Dưới đây là giải thích chi tiết về từng phần của đoạn mã:</p>
<p>Định nghĩa và triển khai cấu trúc Friends
rust
Copy code
struct Friends {
    names: Vec<String>,
}
struct Friends:
Đây là định nghĩa của một cấu trúc (struct) tên là Friends. Cấu trúc này chứa một trường:
names: một vector chứa các chuỗi ký tự (Vec<String>).
Triển khai trait IntoIterator cho Friends
rust
Copy code
impl IntoIterator for Friends {
    type Item = String;
    type IntoIter = std::vec::IntoIter<a href="Self::Item">Self::Item</a>;</p>
<pre><code>fn into_iter(self) -&gt; Self::IntoIter {
    self.names.into_iter()
}
</code></pre>
<p>}
impl IntoIterator for Friends:</p>
<p>Đây là phần triển khai trait IntoIterator cho cấu trúc Friends.
type Item = String:</p>
<p>Xác định kiểu dữ liệu cho các phần tử mà iterator sẽ trả về. Trong trường hợp này, Item là String, nghĩa là iterator sẽ trả về các chuỗi ký tự.
type IntoIter = std::vec::IntoIterSelf::Item:</p>
<p>IntoIter là kiểu của iterator mà trait IntoIterator sẽ trả về. Trong trường hợp này, IntoIter là std::vec::IntoIter<a href="Self::Item">Self::Item</a>, một iterator cho vector các chuỗi ký tự.
fn into_iter(self) -&gt; Self::IntoIter:</p>
<p>Phương thức into_iter chuyển đổi self (một đối tượng của kiểu Friends) thành một iterator.
self.names.into_iter():
Phương thức này gọi into_iter trên trường names của đối tượng Friends, di chuyển các phần tử ra khỏi vector và trả về một iterator cho vector đó.
Sử dụng IntoIterator để lặp qua các phần tử
rust
Copy code
for f in friends {
    println!(&quot;{:?}&quot;, f);
}
for f in friends:</p>
<p>Sử dụng cú pháp for..in để lặp qua tất cả các phần tử của cấu trúc Friends. Cú pháp này sẽ gọi phương thức into_iter được triển khai phía trên để chuyển đổi friends thành một iterator.
println!(&quot;{:?}&quot;, f):</p>
<p>In ra từng phần tử f của iterator. Trong trường hợp này, các phần tử sẽ là các chuỗi ký tự từ vector names.
Kết luận
Ví dụ này cho thấy cách triển khai trait IntoIterator cho cấu trúc Friends và cách sử dụng nó để lặp qua các phần tử của cấu trúc này. Bằng cách triển khai IntoIterator, bạn có thể lặp qua các phần tử của một cấu trúc dữ liệu tùy chỉnh một cách dễ dàng và hiệu quả trong Rust.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Value Moved – Error!

```rust
for f in friends {
    println!("{:?}", f);
}
// `friends` moved due to this implicit call to `.into_iter()`

for f in friends {
    println!("{:?}", f);
}
// ^^^^^^ value used here after move

```

<aside class="notes"><p>minh họa một lỗi phổ biến trong Rust khi di chuyển (move) một giá trị và sau đó cố gắng sử dụng lại giá trị đó. Dưới đây là giải thích chi tiết về vấn đề và lỗi này:</p>
<p>Di chuyển giá trị và lỗi &quot;value used here after move&quot;
rust
Copy code
for f in friends {
    println!(&quot;{:?}&quot;, f);
}
// <code>friends</code> moved due to this implicit call to <code>.into_iter()</code></p>
<p>for f in friends {
    println!(&quot;{:?}&quot;, f);
}
// ^^^^^^ value used here after move
Vòng lặp đầu tiên:</p>
<p>for f in friends:
Khi vòng lặp for được thực hiện trên friends, một cuộc gọi ngầm (implicit call) tới into_iter được thực hiện. Điều này chuyển quyền sở hữu (move) của friends vào iterator.
println!(&quot;{:?}&quot;, f):
In ra từng phần tử f từ iterator.
Giải thích:</p>
<p>Khi into_iter được gọi, quyền sở hữu của friends bị di chuyển (move) vào iterator, nghĩa là friends không còn khả dụng để sử dụng sau cuộc gọi này.
Vòng lặp thứ hai:</p>
<p>for f in friends:
Vòng lặp for thứ hai cố gắng sử dụng lại friends, nhưng friends đã bị di chuyển trong vòng lặp trước đó.
println!(&quot;{:?}&quot;, f):
Rust sẽ phát hiện lỗi này tại thời điểm biên dịch (compile-time) và báo lỗi rằng giá trị friends đã bị di chuyển và không thể sử dụng lại.
Lỗi biên dịch:</p>
<p>value used here after move:
Rust sẽ thông báo rằng giá trị friends đã bị sử dụng sau khi di chuyển. Đây là một cơ chế an toàn của Rust để ngăn chặn lỗi truy cập vào vùng nhớ không hợp lệ.
Kết luận
Ví dụ này minh họa cách Rust quản lý quyền sở hữu (ownership) và di chuyển (move) giá trị để đảm bảo an toàn bộ nhớ. Khi một giá trị bị di chuyển vào một iterator (hoặc bất kỳ nơi nào khác), giá trị đó không thể được sử dụng lại trừ khi được trả lại quyền sở hữu. Điều này giúp tránh lỗi truy cập vào vùng nhớ không hợp lệ và làm cho Rust trở thành một ngôn ngữ an toàn về bộ nhớ.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Borrow

```rust
struct Friends {
    names: Vec<String>,
}

impl<'a> IntoIterator for &'a Friends {
    type Item = &'a String;
    type IntoIter = std::slice::Iter<'a, String>;

    fn into_iter(self) -> Self::IntoIter {
        self.names.iter()
    }
}
```

<aside class="notes"><p>triển khai trait IntoIterator cho một tham chiếu mượn (borrowed reference) của cấu trúc Friends. Điều này cho phép lặp qua các phần tử của Friends mà không di chuyển (move) quyền sở hữu của Friends. Dưới đây là giải thích chi tiết về đoạn mã này:</p>
<p>Định nghĩa và triển khai cấu trúc Friends
rust
Copy code
struct Friends {
    names: Vec<String>,
}
struct Friends:
Đây là định nghĩa của một cấu trúc (struct) tên là Friends. Cấu trúc này chứa một trường:
names: một vector chứa các chuỗi ký tự (Vec<String>).
Triển khai trait IntoIterator cho tham chiếu mượn &amp;Friends
rust
Copy code
impl&lt;&#39;a&gt; IntoIterator for &amp;&#39;a Friends {
    type Item = &amp;&#39;a String;
    type IntoIter = std::slice::Iter&lt;&#39;a, String&gt;;</p>
<pre><code>fn into_iter(self) -&gt; Self::IntoIter {
    self.names.iter()
}
</code></pre>
<p>}
impl&lt;&#39;a&gt; IntoIterator for &amp;&#39;a Friends:</p>
<p>Đây là phần triển khai trait IntoIterator cho một tham chiếu mượn (&amp;Friends) của cấu trúc Friends. &#39;a là một tham số vòng đời (lifetime parameter).
type Item = &amp;&#39;a String:</p>
<p>Xác định kiểu dữ liệu cho các phần tử mà iterator sẽ trả về. Trong trường hợp này, Item là một tham chiếu tới String với vòng đời &#39;a.
type IntoIter = std::slice::Iter&lt;&#39;a, String&gt;:</p>
<p>IntoIter là kiểu của iterator mà trait IntoIterator sẽ trả về. Trong trường hợp này, IntoIter là std::slice::Iter&lt;&#39;a, String&gt;, một iterator cho một lát cắt (slice) của vector các chuỗi ký tự.
fn into_iter(self) -&gt; Self::IntoIter:</p>
<p>Phương thức into_iter chuyển đổi self (một tham chiếu tới đối tượng của kiểu Friends) thành một iterator.
self.names.iter():
Phương thức này gọi iter trên trường names của đối tượng Friends, trả về một iterator cho các phần tử của vector.
Kết luận
Ví dụ này minh họa cách triển khai trait IntoIterator cho một tham chiếu mượn của cấu trúc Friends, cho phép lặp qua các phần tử mà không di chuyển quyền sở hữu của Friends. Điều này giúp tránh lỗi sử dụng lại giá trị sau khi di chuyển (move) và cho phép lặp qua các phần tử của một cấu trúc dữ liệu tùy chỉnh một cách an toàn và hiệu quả trong Rust.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Iteration

```rust
for f in friends {
    println!("{:?}", f);
}
```

<aside class="notes"><p>Giải thích ví dụ về vòng lặp với IntoIterator trait trong Rust
Đoạn mã sau đây minh họa cách sử dụng vòng lặp for để lặp qua các phần tử của đối tượng friends sau khi đã triển khai trait IntoIterator cho kiểu Friends:</p>
<p>rust
Copy code
for f in friends {
    println!(&quot;{:?}&quot;, f);
}
Giải thích chi tiết:
Vòng lặp for:</p>
<p>Câu lệnh for f in friends là cách viết ngắn gọn để lặp qua các phần tử của một iterable trong Rust.
Biến f sẽ nhận giá trị của từng phần tử trong friends trong mỗi lần lặp.
Trait IntoIterator:</p>
<p>Để sử dụng vòng lặp for với một kiểu dữ liệu tùy chỉnh như Friends, cần phải triển khai trait IntoIterator cho kiểu đó.
Đoạn mã trước đó đã triển khai trait IntoIterator cho &amp;Friends (mượn Friends).
Phương thức into_iter:</p>
<p>Khi vòng lặp for được sử dụng, phương thức into_iter sẽ được gọi ngầm định để lấy một iterator cho các phần tử của friends.
Phương thức println!:</p>
<p>Câu lệnh println!(&quot;{:?}&quot;, f); sẽ in ra giá trị của từng phần tử f trong friends.
{:?} là format specifier được sử dụng để in các giá trị dưới dạng debug (hữu ích cho việc kiểm tra và gỡ lỗi).</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Mutable Borrow

```rust
struct Friends {
    names: Vec<String>,
}

impl<'a> IntoIterator for &'a mut Friends {
    type Item = &'a mut String;
    type IntoIter = std::slice::IterMut<'a, String>;

    fn into_iter(self) -> Self::IntoIter {
        self.names.iter_mut()
    }
}
```

<aside class="notes"><p>Giải thích ví dụ về Mutable Borrow với IntoIterator trait trong Rust
Ví dụ này minh họa cách triển khai trait IntoIterator cho một tham chiếu mutable (&amp;mut) tới kiểu dữ liệu Friends. Điều này cho phép bạn lặp qua các phần tử của Friends và thay đổi chúng.</p>
<p>Đoạn mã:
rust
Copy code
struct Friends {
    names: Vec<String>,
}</p>
<p>impl&lt;&#39;a&gt; IntoIterator for &amp;&#39;a mut Friends {
    type Item = &amp;&#39;a mut String;
    type IntoIter = std::slice::IterMut&lt;&#39;a, String&gt;;</p>
<pre><code>fn into_iter(self) -&gt; Self::IntoIter {
    self.names.iter_mut()
}
</code></pre>
<p>}
Giải thích chi tiết:
Cấu trúc Friends:</p>
<p>struct Friends chứa một trường names là một vector của các chuỗi (Vec<String>).
Triển khai IntoIterator cho &amp;mut Friends:</p>
<p>Life time &#39;a: impl&lt;&#39;a&gt; cho biết rằng chúng ta đang làm việc với các tham chiếu có life time &#39;a.
type Item: Định nghĩa loại phần tử (Item) của iterator là một tham chiếu mutable đến một chuỗi (&amp;&#39;a mut String).
type IntoIter: Định nghĩa loại iterator (IntoIter) là std::slice::IterMut&lt;&#39;a, String&gt;, cung cấp iterator mutable qua các phần tử của vector String.
Phương thức into_iter:</p>
<p>Phương thức này trả về một iterator mutable (IterMut) qua các phần tử của names.
self.names.iter_mut() tạo ra một iterator mutable cho phép thay đổi các phần tử của names.
Kết luận
Với triển khai này, bạn có thể sử dụng vòng lặp for để lặp qua các phần tử của Friends một cách mutable, cho phép bạn thay đổi các phần tử trong quá trình lặp. Điều này rất hữu ích khi bạn cần sửa đổi các giá trị trong một cấu trúc dữ liệu khi lặp qua nó.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Iteration

```rust
let names = vec![
    "Albert".to_owned(),
    "Sara".to_owned(),
];

let mut friends = Friends { names };

for f in &mut friends {
    *f = "Frank".to_string();
    println!("{:?}", f);
}
```

<aside class="notes"><p>Giải thích ví dụ về Iteration trong Rust với IntoIterator trait và mutable borrow
Giải thích chi tiết:
Cấu trúc Friends:</p>
<p>struct Friends chứa một trường names là một vector của các chuỗi (Vec<String>).
Triển khai IntoIterator cho &amp;mut Friends:</p>
<p>Life time &#39;a: impl&lt;&#39;a&gt; cho biết rằng chúng ta đang làm việc với các tham chiếu có life time &#39;a.
type Item: Định nghĩa loại phần tử (Item) của iterator là một tham chiếu mutable đến một chuỗi (&amp;&#39;a mut String).
type IntoIter: Định nghĩa loại iterator (IntoIter) là std::slice::IterMut&lt;&#39;a, String&gt;, cung cấp iterator mutable qua các phần tử của vector String.
Phương thức into_iter: Phương thức này trả về một iterator mutable (IterMut) qua các phần tử của names.
Khởi tạo và sử dụng trong hàm main:</p>
<p>Tạo một vector names chứa các chuỗi &quot;Albert&quot; và &quot;Sara&quot;.
Khởi tạo một biến mutable friends thuộc kiểu Friends với vector names.
Sử dụng vòng lặp for để lặp qua các phần tử của friends một cách mutable.
Trong vòng lặp, mỗi phần tử (f) là một tham chiếu mutable đến một chuỗi.
Gán giá trị &quot;Frank&quot; cho mỗi phần tử.
In ra giá trị của mỗi phần tử sau khi gán.
Chương trình sẽ thay đổi tất cả các tên trong vector names của friends thành &quot;Frank&quot; và in chúng ra. Đầu ra sẽ là:</p>
<p>&quot;Frank&quot;
&quot;Frank&quot;
Ví dụ này minh họa cách sử dụng trait IntoIterator để lặp qua các phần tử của một cấu trúc dữ liệu và thay đổi chúng một cách mutable trong Rust.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Iter Methods

- Convention for exposing iteration is to provide up to two methods:
  - .iter()
    - Iteration over borrowed values
  - .iter_mut()
    - Iteration over borrowed mutable values
- Implement these by simply calling into_iter() after implementing the IntoIterator trait
- These are optional, but allow for easy combinator usage without the for loop

<aside class="notes"><p>Các phương thức Iter
Giải thích các ý chính:
Convention for exposing iteration is to provide up to two methods:</p>
<p>Điều này có nghĩa là có một chuẩn mực hoặc phương pháp phổ biến để tạo ra các cách lặp qua các phần tử trong các cấu trúc dữ liệu trong Rust. Cụ thể, người ta thường cung cấp hai phương thức cho việc lặp này:</p>
<p>.iter()</p>
<p>Iteration over borrowed values (Lặp qua các giá trị được mượn)</p>
<p>Phương thức .iter() được sử dụng để lặp qua các tham chiếu tới các phần tử trong cấu trúc dữ liệu. Điều này có nghĩa là bạn có thể lặp qua các phần tử mà không cần sở hữu chúng, cho phép bạn truy cập các phần tử mà không thay đổi hoặc tiêu thụ cấu trúc dữ liệu gốc.</p>
<p>.iter_mut()</p>
<p>Iteration over borrowed mutable values (Lặp qua các giá trị mượn có thể thay đổi)</p>
<p>Phương thức .iter_mut() được sử dụng để lặp qua các tham chiếu có thể thay đổi tới các phần tử trong cấu trúc dữ liệu. Điều này cho phép bạn không chỉ truy cập mà còn có thể thay đổi các phần tử trong khi lặp qua cấu trúc dữ liệu.</p>
<p>Implement these by simply calling into_iter() after implementing the IntoIterator trait</p>
<p>Khi bạn đã triển khai trait IntoIterator cho cấu trúc dữ liệu của mình, bạn có thể dễ dàng triển khai các phương thức .iter() và .iter_mut() bằng cách gọi into_iter(). Điều này tận dụng iterator mà bạn đã định nghĩa, đảm bảo rằng cấu trúc dữ liệu của bạn có thể được lặp qua một cách nhất quán.</p>
<p>These are optional, but allow for easy combinator usage without the for loop</p>
<p>Mặc dù việc triển khai .iter() và .iter_mut() là không bắt buộc, nhưng làm như vậy mang lại nhiều lợi ích. Một lợi ích lớn là nó cho phép bạn sử dụng các combinator của iterator (như map, filter, v.v.) trực tiếp trên cấu trúc dữ liệu của bạn. Điều này có thể dẫn đến mã nguồn ngắn gọn và biểu cảm hơn, vì bạn có thể chuỗi các thao tác lại với nhau thay vì viết các vòng lặp tường minh.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Example

```rust
impl Friends {
    fn iter(&self) -> std::slice::Iter<'_, String> {
        self.into_iter()
    }

    fn iter_mut(&mut self) -> std::slice::IterMut<'_, String> {
        self.into_iter()
    }
}

let total = friends.iter().count();
```

<aside class="notes"><ol>
<li>Triển khai phương thức iter và iter_mut:
impl Friends:</li>
</ol>
<p>Đây là phần triển khai các phương thức cho cấu trúc Friends.
fn iter(&amp;self) -&gt; std::slice::Iter&lt;&#39;_, String&gt;:</p>
<p>&amp;self: Phương thức này nhận một tham chiếu bất biến (&amp;self) tới đối tượng Friends.
std::slice::Iter&lt;&#39;_, String&gt;: Phương thức trả về một iterator bất biến (std::slice::Iter&lt;&#39;_, String&gt;) trên các chuỗi (String) trong đối tượng Friends.
self.into_iter(): Gọi phương thức into_iter() để chuyển đổi đối tượng Friends thành một iterator. Trong trường hợp này, into_iter() trả về một iterator bất biến.
fn iter_mut(&amp;mut self) -&gt; std::slice::IterMut&lt;&#39;_, String&gt;:</p>
<p>&amp;mut self: Phương thức này nhận một tham chiếu có thể thay đổi (&amp;mut self) tới đối tượng Friends.
std::slice::IterMut&lt;&#39;_, String&gt;: Phương thức trả về một iterator có thể thay đổi (std::slice::IterMut&lt;&#39;_, String&gt;) trên các chuỗi (String) trong đối tượng Friends.
self.into_iter(): Gọi phương thức into_iter() để chuyển đổi đối tượng Friends thành một iterator có thể thay đổi. Trong trường hợp này, into_iter() trả về một iterator có thể thay đổi.</p>
<ol start="2">
<li>Đoạn mã sử dụng phương thức iter:
let total = friends.iter().count():
friends.iter(): Gọi phương thức iter trên đối tượng friends để lấy một iterator bất biến.
.count(): Gọi phương thức count() trên iterator để đếm số lượng phần tử trong iterator. Phương thức này trả về tổng số phần tử trong đối tượng friends.</li>
</ol>
</aside></script></section><section  data-markdown><script type="text/template">
# Implementing IntoIterator Using a Custom Iterator

<aside class="notes"><p>Triển khai IntoIterator bằng cách sử dụng một Iterator tùy chỉnh</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Mini Iterator Review

- Iterator trait allows iteration over a collection
  - Yield items
  - Struct must be mutable & contain iteration state information
- IntoIterator trait defines a proxy struct & determines how data is accessed
  - Move, borrow, mutation

<aside class="notes"><p>Iterator Trait
Allows iteration over a collection: Iterator trait cho phép lặp qua một tập hợp các phần tử.
Yield items: Trả về từng phần tử một.
Struct must be mutable &amp; contain iteration state information: Cấu trúc phải có khả năng thay đổi và chứa thông tin về trạng thái lặp.
IntoIterator Trait
Defines a proxy struct &amp; determines how data is accessed: Đặc tính này định nghĩa một struct proxy và xác định cách truy cập dữ liệu.
Move: Di chuyển quyền sở hữu dữ liệu.
Borrow: Mượn dữ liệu mà không di chuyển quyền sở hữu.
Mutation: Cho phép thay đổi dữ liệu trong khi lặp.
Giải thích chi tiết:</p>
<p>Iterator Trait:</p>
<p>Đặc tính Iterator là một phần quan trọng trong Rust, cho phép bạn lặp qua một tập hợp các phần tử trong một cấu trúc dữ liệu.
Để triển khai Iterator, bạn cần cung cấp một phương thức next trả về các phần tử từng cái một.
Cấu trúc triển khai Iterator phải có khả năng thay đổi (mutable) và chứa thông tin về trạng thái lặp, ví dụ như vị trí hiện tại trong tập hợp các phần tử.
IntoIterator Trait:</p>
<p>Đặc tính IntoIterator cho phép chuyển đổi một cấu trúc dữ liệu thành một iterator. Nó định nghĩa một struct proxy và xác định cách dữ liệu được truy cập.
IntoIterator có thể triển khai theo ba cách chính:
Move: Di chuyển quyền sở hữu của dữ liệu từ cấu trúc dữ liệu vào iterator.
Borrow: Mượn dữ liệu từ cấu trúc dữ liệu mà không di chuyển quyền sở hữu.
Mutation: Cho phép thay đổi dữ liệu trong khi lặp qua nó.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Problem

- Implementing IntoIterator allows control of the iteration, but...
  - We aren’t using an existing collection to store data
    - No .iter() or .into_iter()
  - We don’t want to pollute our data structure with iteration information

<aside class="notes"><p>Implementing IntoIterator allows control of the iteration:</p>
<p>Triển khai đặc tính IntoIterator cho phép bạn kiểm soát quá trình lặp lại (iteration) của dữ liệu trong cấu trúc của bạn.
We aren’t using an existing collection to store data:</p>
<p>No .iter() or .into_iter():
Trong một số trường hợp, bạn không sử dụng các bộ sưu tập có sẵn như Vec, HashMap để lưu trữ dữ liệu. Do đó, bạn không thể sử dụng các phương thức .iter() hoặc .into_iter() mặc định.
We don’t want to pollute our data structure with iteration information:</p>
<p>Bạn không muốn làm &quot;ô nhiễm&quot; (pollute) cấu trúc dữ liệu của mình với thông tin về quá trình lặp lại. Điều này có nghĩa là bạn không muốn thêm các biến hoặc logic chỉ để phục vụ cho quá trình lặp lại, làm phức tạp và khó duy trì cấu trúc dữ liệu của bạn.
Vấn đề này đặt ra thách thức trong việc triển khai quá trình lặp lại cho các cấu trúc dữ liệu tùy chỉnh mà không sử dụng các bộ sưu tập có sẵn và không làm phức tạp thêm cấu trúc dữ liệu ban đầu.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Solution

- Make an intermediary struct
  - Implement Iterator
    - Mutable, handles iteration state
- Implement IntoIterator on data struct
  - Combined with the intermediary struct will allow iteration

<aside class="notes"><p>Giải thích chi tiết:</p>
<p>Make an intermediary struct:
Implement Iterator:
Tạo một cấu trúc trung gian và triển khai đặc tính Iterator cho nó. Cấu trúc trung gian này sẽ có trạng thái lặp lại và có thể thay đổi (mutable), giúp xử lý quá trình lặp lại.
Implement IntoIterator on data struct:
Kết hợp với cấu trúc trung gian sẽ cho phép lặp lại (iteration).
Triển khai đặc tính IntoIterator cho cấu trúc dữ liệu chính của bạn. Cấu trúc dữ liệu chính này sẽ sử dụng cấu trúc trung gian để thực hiện quá trình lặp lại mà không làm ô nhiễm (pollute) cấu trúc dữ liệu ban đầu với thông tin lặp lại.
Bằng cách tạo một cấu trúc trung gian để xử lý trạng thái lặp lại, bạn có thể giữ cho cấu trúc dữ liệu chính của mình gọn gàng và tách biệt khỏi logic lặp lại. Điều này giúp duy trì mã nguồn dễ đọc, dễ bảo trì và hiệu quả trong việc quản lý dữ liệu và quá trình lặp lại.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Setup

```rust
struct Color {
    r: u8,
    g: u8,
    b: u8,
}

struct ColorIntoIter {
    color: Color,
    position: u8,
}

struct ColorIter<'a> {
    color: &'a Color,
    position: u8,
}
```

<aside class="notes"><p>struct Color:</p>
<p>Đây là định nghĩa của một cấu trúc Color, chứa ba trường r, g, b đại diện cho các giá trị màu đỏ, xanh lá và xanh dương. Mỗi trường có kiểu dữ liệu u8, biểu thị giá trị từ 0 đến 255.
struct ColorIntoIter:</p>
<p>Đây là cấu trúc trung gian ColorIntoIter, chứa hai trường:
color: một đối tượng Color.
position: một giá trị u8 đại diện cho vị trí hiện tại trong quá trình lặp lại (iteration).
struct ColorIter&lt;&#39;a&gt;:</p>
<p>Đây là một cấu trúc khác ColorIter, sử dụng tham chiếu mượn (borrowed reference) để truy cập đối tượng Color.
&#39;a là tham số vòng đời (lifetime parameter) đảm bảo rằng tham chiếu đến Color sống lâu hơn ColorIter.
Trường color là một tham chiếu đến Color và position đại diện cho vị trí hiện tại trong quá trình lặp lại.
Bằng cách thiết lập các cấu trúc này, chúng ta chuẩn bị cho việc triển khai các đặc tính Iterator và IntoIterator, cho phép lặp qua các giá trị màu sắc của Color một cách an toàn và hiệu quả.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Review – Iterator Trait

```rust
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}
```

<aside class="notes"><p>trait Iterator:</p>
<p>Đây là định nghĩa của một trait tên là Iterator. Trong Rust, trait là một tập hợp các phương thức mà một kiểu dữ liệu có thể triển khai.
type Item:</p>
<p>Đây là một kiểu liên kết (associated type). Item đại diện cho kiểu dữ liệu của các phần tử mà iterator sẽ trả về. Khi triển khai trait Iterator cho một kiểu dữ liệu cụ thể, bạn cần chỉ định kiểu dữ liệu cho Item.
fn next(&amp;mut self) -&gt; OptionSelf::Item:</p>
<p>Đây là phương thức bắt buộc cần phải triển khai khi một kiểu dữ liệu triển khai trait Iterator.
Phương thức next nhận một tham chiếu thay đổi đến chính nó (&amp;mut self) và trả về Option<a href="Self::Item">Self::Item</a>.
Option<a href="Self::Item">Self::Item</a> có thể là Some(Item) nếu iterator có phần tử kế tiếp hoặc None nếu iterator đã hoàn thành việc lặp.</p>
<p>Iterator là trait quan trọng trong Rust cho phép lặp qua các phần tử của một cấu trúc dữ liệu.
Phương thức next: Triển khai phương thức này để xác định cách lấy phần tử kế tiếp từ iterator.
Option<a href="Self::Item">Self::Item</a>: Sử dụng Option để biểu thị kết quả có thể là phần tử hợp lệ (Some(Item)) hoặc không có phần tử nào nữa (None).
Việc hiểu và triển khai trait Iterator là cơ bản để làm việc với các cấu trúc dữ liệu và lặp trong Rust một cách hiệu quả và an toàn.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Impl Iterator - Move

```rust
struct Color {
    r: u8,
    g: u8,
    b: u8,
}

struct ColorIntoIter {
    color: Color,
    position: u8,
}

impl Iterator for ColorIntoIter {
    type Item = u8;

    fn next(&mut self) -> Option<Self::Item> {
        let next = match self.position {
            0 => Some(self.color.r),
            1 => Some(self.color.g),
            2 => Some(self.color.b),
            _ => None,
        };
        self.position += 1;
        next
    }
}

```

<aside class="notes"><p>Triển khai struct Color: Lưu trữ các giá trị màu RGB.
Triển khai struct ColorIntoIter: Sử dụng để lưu trạng thái lặp.
Triển khai trait Iterator cho ColorIntoIter:
type Item = u8: Các phần tử sẽ là các giá trị nguyên không dấu 8-bit.
fn next(&amp;mut self) -&gt; Option<a href="Self::Item">Self::Item</a>: Trả về phần tử tiếp theo hoặc None nếu không còn phần tử nào, và cập nhật trạng thái lặp.
Các slide này giúp hiểu rõ cách triển khai IntoIterator và Iterator trong Rust, cùng với cách sử dụng chúng để lặp qua các phần tử của một cấu trúc dữ liệu.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Impl IntoIterator - Move

```rust
struct Color {
    r: u8,
    g: u8,
    b: u8,
}

struct ColorIntoIter {
    color: Color,
    position: u8,
}

impl IntoIterator for Color {
    type Item = u8;
    type IntoIter = ColorIntoIter;

    fn into_iter(self) -> Self::IntoIter {
        ColorIntoIter {
            color: self,
            position: 0,
        }
    }
}
```

<aside class="notes"><p>Định nghĩa struct Color:</p>
<p>Struct Color lưu trữ ba giá trị màu sắc dưới dạng các số nguyên không dấu 8-bit (u8):
Định nghĩa struct ColorIntoIter:</p>
<p>Struct ColorIntoIter dùng để lưu trữ trạng thái lặp khi thực hiện việc lặp qua các giá trị của một đối tượng Color. Struct này bao gồm:
color: đối tượng Color mà chúng ta muốn lặp qua.
position: vị trí hiện tại trong quá trình lặp, được biểu diễn bằng một số nguyên không dấu 8-bit (u8):
Triển khai trait IntoIterator cho struct Color:</p>
<p>Trait IntoIterator cho phép một đối tượng có thể chuyển đổi thành một iterator. Điều này có nghĩa là bạn có thể lặp qua các phần tử của đối tượng đó.
Trong trường hợp này, chúng ta triển khai IntoIterator cho struct Color
Phương thức into_iter chuyển đổi self (một đối tượng Color) thành một iterator:
Tóm tắt:
Struct Color lưu trữ ba giá trị màu sắc.
Struct ColorIntoIter được sử dụng để lưu trữ trạng thái lặp khi thực hiện việc lặp qua các giá trị của Color.
Triển khai IntoIterator cho phép chuyển đổi một đối tượng Color thành một iterator bằng cách tạo một đối tượng ColorIntoIter với vị trí bắt đầu là 0. Điều này cho phép lặp qua các giá trị màu sắc của Color (r, g, b) một cách tuần tự.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Done!

```rust
let color = Color {
    r: 10,
    g: 20,
    b: 30,
};

for c in color {
    println!("{}", c);
}

// 10
// 20
// 30
```

<aside class="notes"><p>Đoạn mã này minh họa cách sử dụng IntoIterator để lặp qua các thành phần của một đối tượng Color.
Đầu tiên, đối tượng Color được khởi tạo với các giá trị r, g, và b.
Sau đó, vòng lặp for được sử dụng để lặp qua từng thành phần của đối tượng Color và in ra các giá trị này.
Kết quả là các giá trị 10, 20, và 30 được in ra tuần tự, cho thấy quá trình lặp qua các thành phần của đối tượng Color hoạt động chính xác.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Overview

```rust
let color = Color {
    r: 10,
    g: 20,
    b: 30,
};

for c in color {
    println!("{}", c);
}

struct ColorIntoIter {
    color: Color,
    position: u8,
}

struct Color {
    r: u8,
    g: u8,
    b: u8,
}
```

<aside class="notes"><p>Khởi tạo đối tượng Color:
Đối tượng Color được khởi tạo với các giá trị r, g, và b tương ứng là 10, 20, và 30
Đây là một đối tượng Color với màu đỏ là 10, màu xanh lá là 20, và màu xanh dương là 30.</p>
<p>Sử dụng vòng lặp for để lặp qua các phần tử của Color:</p>
<p>Vòng lặp for được sử dụng để lặp qua từng phần tử của đối tượng Color
Vòng lặp này sẽ lặp qua các giá trị r, g, và b của đối tượng Color và in chúng ra.
Kết quả:</p>
<p>Khi thực thi đoạn mã trên, kết quả sẽ là:
Copy code
10
20
30
Các giá trị 10, 20, và 30 tương ứng với các thành phần r, g, và b của đối tượng Color được in ra lần lượt.
Định nghĩa cấu trúc ColorIntoIter:</p>
<p>Cấu trúc ColorIntoIter được định nghĩa để giữ trạng thái của quá trình lặp:
rust
Copy code
struct ColorIntoIter {
    color: Color,
    position: u8,
}
ColorIntoIter có hai trường: color là một đối tượng Color và position là một số nguyên 8-bit không dấu (u8) để theo dõi vị trí hiện tại trong quá trình lặp.
Định nghĩa cấu trúc Color:</p>
<p>Cấu trúc Color được định nghĩa với ba trường r, g, và b đại diện cho ba kênh màu:
rust
Copy code
struct Color {
    r: u8,
    g: u8,
    b: u8,
}
Tóm tắt:
Đoạn mã này minh họa cách sử dụng IntoIterator để lặp qua các thành phần của một đối tượng Color.
Đầu tiên, đối tượng Color được khởi tạo với các giá trị r, g, và b.
Sau đó, vòng lặp for được sử dụng để lặp qua từng thành phần của đối tượng Color và in ra các giá trị này.
Kết quả là các giá trị 10, 20, và 30 được in ra tuần tự, cho thấy quá trình lặp qua các thành phần của đối tượng Color hoạt động chính xác.
Cấu trúc ColorIntoIter được sử dụng để giữ trạng thái của quá trình lặp, và cấu trúc Color định nghĩa các kênh màu.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Impl Iterator - Borrow

```rust
impl<'a> Iterator for ColorIter<'a> {
    type Item = u8;

    fn next(&mut self) -> Option<Self::Item> {
        let next = match self.position {
            0 => Some(self.color.r),
            1 => Some(self.color.g),
            2 => Some(self.color.b),
            _ => None,
        };

        self.position += 1;
        next
    }
}

struct Color {
    r: u8,
    g: u8,
    b: u8,
}

struct ColorIter<'a> {
    color: &'a Color,
    position: u8,
}
```
<aside class="notes"><p>Slide này giải thích cách triển khai (implement) trait Iterator cho một cấu trúc (struct) trong Rust mà sử dụng mượn (borrow) thay vì di chuyển (move). Trong ví dụ này, chúng ta sử dụng cấu trúc Color và triển khai iterator để lặp qua các thành phần của nó.</p>
<p>Mã nguồn trong slide:
Định nghĩa Structs:
rust
Copy code
struct Color {
    r: u8,
    g: u8,
    b: u8,
}
Đây là định nghĩa của cấu trúc Color, chứa ba thành phần màu r, g, và b với kiểu dữ liệu u8.
rust
Copy code
struct ColorIter&lt;&#39;a&gt; {
    color: &amp;&#39;a Color,
    position: u8,
}
ColorIter là một iterator cho Color, chứa một tham chiếu mượn (borrow) đến Color và một biến position để theo dõi trạng thái hiện tại của việc lặp.
Triển khai Trait Iterator:
rust
Copy code
impl&lt;&#39;a&gt; Iterator for ColorIter&lt;&#39;a&gt; {
    type Item = u8;</p>
<pre><code>fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    let next = match self.position {
        0 =&gt; Some(self.color.r),
        1 =&gt; Some(self.color.g),
        2 =&gt; Some(self.color.b),
        _ =&gt; None,
    };

    self.position += 1;
    next
}
</code></pre>
<p>}
impl&lt;&#39;a&gt; Iterator for ColorIter&lt;&#39;a&gt;: Triển khai trait Iterator cho ColorIter.
type Item = u8: Xác định kiểu phần tử mà iterator trả về, trong trường hợp này là u8.
fn next(&amp;mut self) -&gt; Option<a href="Self::Item">Self::Item</a>: Phương thức next trả về phần tử tiếp theo của iterator hoặc None nếu không còn phần tử nào.
Sử dụng match để kiểm tra giá trị của position và trả về thành phần tương ứng (r, g, hoặc b).
Tăng giá trị position lên 1 sau mỗi lần lặp.
Ý nghĩa:
Slide này minh họa cách tạo một iterator mà không di chuyển giá trị ra khỏi cấu trúc ban đầu, thay vào đó, chỉ mượn các giá trị.
Điều này cho phép iterator hoạt động mà không làm mất dữ liệu gốc, hữu ích trong các trường hợp bạn cần lặp qua dữ liệu mà không muốn thay đổi hoặc di chuyển chúng.
Kết luận, việc triển khai iterator sử dụng mượn (borrow) giúp bảo toàn dữ liệu gốc và cho phép lặp qua các phần tử một cách an toàn và hiệu quả.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Impl IntoIterator - Borrow

```rust
impl<'a> IntoIterator for &'a Color {
    type Item = u8;
    type IntoIter = ColorIter<'a>;

    fn into_iter(self) -> Self::IntoIter {
        ColorIter {
            color: &self,
            position: 0,
        }
    }
}

struct Color {
    r: u8,
    g: u8,
    b: u8,
}

struct ColorIter<'a> {
    color: &'a Color,
    position: u8,
}
```

<aside class="notes"><p>Slide này trình bày cách triển khai trait IntoIterator cho một tham chiếu mượn (&amp;Color) của một cấu trúc Color trong Rust. Dưới đây là giải thích chi tiết từng phần của mã nguồn.</p>
<p>Mã nguồn trong slide:
Định nghĩa Structs:
rust
Copy code
struct Color {
    r: u8,
    g: u8,
    b: u8,
}
Đây là định nghĩa của cấu trúc Color, chứa ba thành phần màu r, g, và b với kiểu dữ liệu u8.
rust
Copy code
struct ColorIter&lt;&#39;a&gt; {
    color: &amp;&#39;a Color,
    position: u8,
}
ColorIter là một iterator cho Color, chứa một tham chiếu mượn (&amp;&#39;a Color) đến Color và một biến position để theo dõi trạng thái hiện tại của việc lặp.
Triển khai Trait IntoIterator:
rust
Copy code
impl&lt;&#39;a&gt; IntoIterator for &amp;&#39;a Color {
    type Item = u8;
    type IntoIter = ColorIter&lt;&#39;a&gt;;</p>
<pre><code>fn into_iter(self) -&gt; Self::IntoIter {
    ColorIter {
        color: &amp;self,
        position: 0,
    }
}
</code></pre>
<p>}
impl&lt;&#39;a&gt; IntoIterator for &amp;&#39;a Color: Triển khai trait IntoIterator cho một tham chiếu mượn của Color.
type Item = u8: Xác định kiểu phần tử mà iterator trả về, trong trường hợp này là u8.
type IntoIter = ColorIter&lt;&#39;a&gt;: Xác định kiểu của iterator mà IntoIterator sẽ trả về, trong trường hợp này là ColorIter&lt;&#39;a&gt;.
fn into_iter(self) -&gt; Self::IntoIter: Phương thức into_iter chuyển đổi self (một tham chiếu mượn của Color) thành một iterator.
Trả về một ColorIter mới với color là tham chiếu đến self và position ban đầu là 0.
Ý nghĩa:
Slide này minh họa cách tạo một iterator cho một tham chiếu mượn của một cấu trúc dữ liệu.
Triển khai IntoIterator cho phép sử dụng cú pháp for..in để lặp qua các phần tử của Color mà không cần di chuyển dữ liệu gốc.
Điều này đặc biệt hữu ích khi bạn chỉ cần lặp qua dữ liệu mà không muốn thay đổi hoặc di chuyển chúng.
Ví dụ:
Sử dụng đoạn mã trên, bạn có thể lặp qua các thành phần màu của một Color như sau:</p>
<p>rust
Copy code
let color = Color { r: 10, g: 20, b: 30 };</p>
<p>for c in &amp;color {
    println!(&quot;{}&quot;, c);
}
Mã này sẽ in ra các giá trị của r, g, và b từ cấu trúc Color.
Kết luận, triển khai IntoIterator cho một tham chiếu mượn (&amp;Color) giúp bạn có thể lặp qua các phần tử của cấu trúc dữ liệu một cách an toàn và hiệu quả, mà không cần thay đổi hoặc di chuyển dữ liệu gốc.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Done

```rust
let color = Color {
    r: 10,
    g: 20,
    b: 30,
};

for c in &color {
    println!("{}", c);
}

for c in &color {
    println!("{}", c);
}

// 10
// 20
// 30
// 10
// 20
// 30
```

<aside class="notes"><p>Slide này trình bày cách sử dụng iterator đã triển khai để lặp qua các phần tử của cấu trúc Color trong Rust.</p>
<p>Mã nguồn trong slide:
rust
Copy code
let color = Color {
    r: 10,
    g: 20,
    b: 30,
};</p>
<p>for c in &amp;color {
    println!(&quot;{}&quot;, c);
}</p>
<p>for c in &amp;color {
    println!(&quot;{}&quot;, c);
}
Định nghĩa cấu trúc Color:
rust
Copy code
struct Color {
    r: u8,
    g: u8,
    b: u8,
}
Color là một cấu trúc chứa ba thành phần màu r, g, và b với kiểu dữ liệu u8.
Tạo một đối tượng Color:
rust
Copy code
let color = Color {
    r: 10,
    g: 20,
    b: 30,
};
Tạo một đối tượng color với các giá trị cụ thể cho r, g, và b.
Sử dụng vòng lặp for để lặp qua các phần tử của Color:
rust
Copy code
for c in &amp;color {
    println!(&quot;{}&quot;, c);
}
Vòng lặp for đầu tiên sử dụng cú pháp for c in &amp;color để lặp qua các thành phần của color.
Phương thức println!(&quot;{}&quot;, c); sẽ in giá trị của từng phần tử c.
Lặp lại vòng lặp for một lần nữa:
rust
Copy code
for c in &amp;color {
    println!(&quot;{}&quot;, c);
}
Vòng lặp for thứ hai thực hiện tương tự, in lại các giá trị của color.
Kết quả đầu ra:
arduino
Copy code
// 10
// 20
// 30
// 10
// 20
// 30
Kết quả đầu ra hiển thị các giá trị của r, g, và b của color hai lần, một lần cho mỗi vòng lặp for.
Ý nghĩa:
Slide này minh họa rằng việc triển khai IntoIterator cho một tham chiếu mượn (&amp;Color) cho phép bạn sử dụng cú pháp for..in để lặp qua các phần tử của Color nhiều lần mà không thay đổi hoặc di chuyển dữ liệu gốc.
Đây là một ví dụ cụ thể về việc tận dụng sức mạnh của iterator trong Rust để làm cho mã nguồn dễ đọc và hiệu quả hơn.
Bằng cách triển khai IntoIterator cho một tham chiếu mượn của Color, bạn có thể lặp qua các thành phần của nó một cách an toàn và tái sử dụng cùng một đối tượng Color nhiều lần trong các vòng lặp for.</p>
</aside></script></section><section  data-markdown><script type="text/template">
## Notes

- Non-trivial to implement mutable iteration using IntoIterator
  - Collect mutable references into a Vector and return it
  - Use unsafe to bypass compiler checks
- Prefer using existing .iter() methods on structures when possible
  - Vectors, HashMaps, etc
  - Easier to work with, covers most cases

<aside class="notes"><p>Slide này cung cấp những ghi chú quan trọng về việc triển khai lặp lại thay đổi (mutable iteration) và lời khuyên khi sử dụng các phương thức lặp lại trong Rust.</p>
<p>Non-trivial to implement mutable iteration using IntoIterator:</p>
<p>Việc triển khai lặp lại thay đổi (mutable iteration) bằng cách sử dụng trait IntoIterator không phải là điều đơn giản. Điều này đòi hỏi những kỹ thuật đặc biệt để quản lý các tham chiếu thay đổi (mutable references) trong quá trình lặp.
Collect mutable references into a Vector and return it:</p>
<p>Một cách để giải quyết vấn đề này là thu thập tất cả các tham chiếu thay đổi (mutable references) vào một Vector và trả về Vector đó. Tuy nhiên, cách này có thể phức tạp và không trực tiếp.
Use unsafe to bypass compiler checks:</p>
<p>Trong một số trường hợp, bạn có thể sử dụng khối lệnh unsafe để vượt qua các kiểm tra của trình biên dịch. Tuy nhiên, sử dụng unsafe cần rất cẩn thận vì nó có thể dẫn đến lỗi bộ nhớ nếu không được quản lý đúng cách.
Prefer using existing .iter() methods on structures when possible:</p>
<p>Nên ưu tiên sử dụng các phương thức .iter() có sẵn trên các cấu trúc dữ liệu khi có thể. Các phương thức này được thiết kế sẵn để dễ dàng sử dụng và tối ưu hóa cho việc lặp lại.
Vectors, HashMaps, etc:</p>
<p>Các cấu trúc dữ liệu như Vectors, HashMaps, v.v., thường có sẵn các phương thức .iter() hoặc .iter_mut() để lặp qua các phần tử một cách dễ dàng và an toàn.
Easier to work with, covers most cases:</p>
<p>Sử dụng các phương thức .iter() có sẵn sẽ dễ dàng hơn để làm việc và bao phủ hầu hết các trường hợp sử dụng phổ biến trong Rust. Điều này giúp mã nguồn của bạn trở nên sạch sẽ, dễ đọc và ít lỗi hơn.
Tóm tắt:
Việc triển khai lặp lại thay đổi (mutable iteration) bằng IntoIterator có thể phức tạp và đòi hỏi các kỹ thuật đặc biệt.
Nên ưu tiên sử dụng các phương thức lặp lại có sẵn như .iter() và .iter_mut() trên các cấu trúc dữ liệu như Vectors, HashMaps.
Sử dụng các phương thức có sẵn giúp mã nguồn dễ làm việc hơn và bao phủ hầu hết các trường hợp sử dụng phổ biến.</p>
</aside></script></section>
    </article>
  </main>

  <script src="./../../dist/reveal.js"></script>

  <script src="./../../plugin/markdown/markdown.js"></script>
  <script src="./../../plugin/highlight/highlight.js"></script>
  <script src="./../../plugin/zoom/zoom.js"></script>
  <script src="./../../plugin/notes/notes.js"></script>
  <script src="./../../plugin/math/math.js"></script>

  <script src="./../../assets/plugin/mermaid.js"></script>
  <script src="./../../assets/plugin/mermaid-theme.js"></script>

  <script src="./../../assets/plugin/chart/chart.js"></script>
  <script src="./../../assets/plugin/chart/chart.min.js"></script>

  <script src="./../../assets/plugin/tailwindcss.min.js"></script>

  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: true,
      transition: 'default', // none/fade/slide/convex/concave/zoom
      slideNumber: true,
      mermaid: {
        startOnLoad: false,
        logLevel: 3,
        theme: 'base',
        themeVariables: {
          primaryColor: purple,
          primaryTextColor: white,
          primaryBorderColor: pink,
          lineColor: pink,
          secondaryColor: lightPurple,
          tertiaryColor: lightPurple,
        },
      },
      chart: {
        defaults: {
          color: 'lightgray', // color of labels
          scale: {
            beginAtZero: true,
            ticks: { stepSize: 1 },
            grid: { color: "lightgray" }, // color of grid lines
          },
        },
        line: { borderColor: ["#ccc", "#E6007A", "#6D3AEE"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["#ccc", "#E6007A", "#6D3AEE"] },
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath,
        RevealMermaid,
        RevealChart
      ]
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"width":1400,"height":900,"margin":0,"minScale":0.2,"maxScale":2,"transition":"none","controls":true,"progress":true,"center":true,"slideNumber":true,"backgroundTransition":"fade"}, queryOptions);
  </script>


  <script>
    Reveal.initialize(options);
  </script>
</body>

</html>
